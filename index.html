<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real Academic Citation Generator - Semantic Scholar, CrossRef, arXiv</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    <style>
        body { font-family: 'Inter', sans-serif; }
        
        .cited-sentence {
            background: linear-gradient(to right, transparent 0%, #f0fdf4 2%, #f0fdf4 98%, transparent 100%);
            padding: 4px 0;
            margin: 8px 0;
            border-left: 3px solid #10b981;
            padding-left: 8px;
            border-radius: 2px;
            transition: all 0.3s ease;
        }
        
        .cited-sentence:hover {
            background: #dcfce7;
            border-left-width: 4px;
        }
        
        .citation-number {
            display: inline-block;
            color: #2563eb;
            font-weight: 600;
            cursor: pointer;
            vertical-align: super;
            font-size: 0.85em;
            padding: 0 2px;
            transition: all 0.2s ease;
        }
        
        .citation-number:hover {
            color: #1d4ed8;
            text-decoration: underline;
            background: #dbeafe;
            border-radius: 2px;
            padding: 1px 4px;
        }
        
        .reference-card {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            transition: all 0.3s ease;
        }
        
        .reference-card:hover {
            border-color: #3b82f6;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.1);
            transform: translateY(-2px);
        }
        
        .doi-link {
            color: #059669;
            text-decoration: none;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        
        .doi-link:hover {
            color: #047857;
            text-decoration: underline;
        }
        
        .api-status {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .api-status.active {
            background: #d1fae5;
            color: #065f46;
        }
        
        .api-status.inactive {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .search-progress {
            background: #f3f4f6;
            border-radius: 8px;
            padding: 12px;
            margin-top: 8px;
        }
        
        .progress-bar {
            background: #e5e7eb;
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            height: 100%;
            transition: width 0.3s ease;
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        .sentence-number {
            display: inline-block;
            width: 30px;
            color: #9ca3af;
            font-size: 12px;
            font-weight: 600;
        }
        
        @media print {
            .no-print { display: none !important; }
            .cited-sentence { 
                background: none;
                border-left: none;
                padding-left: 0;
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-50 min-h-screen">
    
    <!-- Header -->
    <header class="bg-white shadow-sm border-b no-print">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-4">
                    <div class="bg-blue-600 p-3 rounded-lg">
                        <i class="fas fa-quote-right text-white text-2xl"></i>
                    </div>
                    <div>
                        <h1 class="text-3xl font-bold text-gray-900">Real Academic Citation Generator</h1>
                        <p class="text-sm text-gray-600 mt-1">Powered by 7 Free Academic APIs (+ 4 Premium) with AI-Enhanced Relevance Scoring</p>
                    </div>
                </div>
                <div class="flex items-center space-x-4">
                    <div class="api-status active" id="apiStatus">
                        <i class="fas fa-circle text-xs"></i>
                        APIs Ready
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        
        <!-- API Configuration (Optional) -->
        <div class="bg-white rounded-xl shadow-lg p-6 mb-8 no-print">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-xl font-bold text-gray-900">
                    <i class="fas fa-key mr-2 text-blue-600"></i>
                    API Configuration (Optional - Free APIs work without keys)
                </h2>
                <button onclick="toggleAPIConfig()" class="text-sm text-blue-600 hover:text-blue-700">
                    <i class="fas fa-cog mr-1"></i>Configure
                </button>
            </div>
            
            <div id="apiConfig" class="hidden space-y-4">
                <div class="bg-blue-50 rounded-lg p-4">
                    <p class="text-sm text-gray-700 mb-3">
                        <i class="fas fa-info-circle text-blue-600 mr-2"></i>
                        <strong>All these APIs are FREE and work without API keys!</strong> You can optionally add keys for higher rate limits.
                    </p>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">
                                Semantic Scholar API Key (Optional)
                                <a href="https://www.semanticscholar.org/product/api" target="_blank" class="text-blue-600 ml-2">
                                    <i class="fas fa-external-link-alt text-xs"></i>
                                </a>
                            </label>
                            <input type="text" id="semanticScholarKey" placeholder="Not required - works without key"
                                   class="w-full px-4 py-2 border rounded-lg">
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">
                                CrossRef Email (Polite Pool)
                                <a href="https://www.crossref.org/documentation/retrieve-metadata/rest-api/" target="_blank" class="text-blue-600 ml-2">
                                    <i class="fas fa-external-link-alt text-xs"></i>
                                </a>
                            </label>
                            <input type="email" id="crossrefEmail" placeholder="your@email.com for faster responses"
                                   class="w-full px-4 py-2 border rounded-lg">
                        </div>
                    </div>
                    
                    <div class="mt-3 text-xs text-gray-600">
                        <strong>Note:</strong> arXiv API is completely free and requires no authentication.
                    </div>
                </div>
            </div>
        </div>

        <!-- Input Section -->
        <div class="bg-white rounded-xl shadow-lg p-8 mb-8 no-print">
            <div class="flex items-center justify-between mb-6">
                <h2 class="text-2xl font-bold text-gray-900">
                    <i class="fas fa-paste mr-2 text-blue-600"></i>
                    Input Your Text
                </h2>
                <span class="text-sm text-gray-500">Paste text that needs real citations</span>
            </div>

            <div class="space-y-6">
                <!-- Text Input -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">
                        Your Text (Semantic chunks will be analyzed for citations)
                    </label>
                    <textarea 
                        id="inputText" 
                        placeholder="Paste your text here. Each sentence will be analyzed and matched with REAL academic papers from Semantic Scholar, CrossRef, and arXiv with verified DOI links.&#10;&#10;Example:&#10;Machine learning has revolutionized healthcare diagnostics. Deep learning algorithms can detect diseases from medical images with high accuracy. Natural language processing is being used to analyze patient records."
                        class="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition"
                        rows="12"
                        style="font-family: 'Inter', sans-serif; font-size: 15px; line-height: 1.8;"
                    ></textarea>
                    <div class="flex justify-between items-center mt-2">
                        <span class="text-sm text-gray-500">
                            <span id="charCount">0</span> characters â€¢ 
                            <span id="sentenceCount">0</span> sentences detected
                        </span>
                        <button onclick="clearInput()" class="text-sm text-red-600 hover:text-red-700">
                            <i class="fas fa-times mr-1"></i>Clear
                        </button>
                    </div>
                </div>

                <!-- Settings -->
                <div class="bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg p-6">
                    <h3 class="font-semibold text-gray-900 mb-4">
                        <i class="fas fa-cog mr-2 text-blue-600"></i>
                        Citation Settings
                    </h3>
                    
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <!-- Citation Style -->
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">Citation Style</label>
                            <select id="citationStyle" class="w-full px-4 py-2 border border-gray-300 rounded-lg bg-white focus:ring-2 focus:ring-blue-500">
                                <option value="apa">APA 7th Edition</option>
                                <option value="mla">MLA 9th Edition</option>
                                <option value="chicago">Chicago 17th</option>
                                <option value="harvard">Harvard</option>
                                <option value="ieee">IEEE</option>
                                <option value="vancouver">Vancouver</option>
                            </select>
                        </div>

                        <!-- Year Range -->
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">Publication Year</label>
                            <select id="yearRange" class="w-full px-4 py-2 border border-gray-300 rounded-lg bg-white focus:ring-2 focus:ring-blue-500">
                                <option value="5">Last 5 years</option>
                                <option value="10">Last 10 years</option>
                                <option value="15">Last 15 years</option>
                                <option value="all">All years</option>
                            </select>
                        </div>

                        <!-- Results per sentence -->
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">Citations per Chunk</label>
                            <select id="citationsPerSentence" class="w-full px-4 py-2 border border-gray-300 rounded-lg bg-white focus:ring-2 focus:ring-blue-500">
                                <option value="1">1 citation</option>
                                <option value="2">2 citations</option>
                                <option value="3">3 citations</option>
                            </select>
                        </div>
                    </div>

                    <!-- API Sources -->
                    <div class="mt-4">
                        <label class="block text-sm font-medium text-gray-700 mb-2">Search Sources (7 Free APIs + 4 Premium)</label>
                        <div class="grid grid-cols-3 gap-3">
                            <label class="flex items-center space-x-2 text-sm">
                                <input type="checkbox" id="useSemanticScholar" checked class="rounded text-blue-600 focus:ring-blue-500">
                                <span>Semantic Scholar</span>
                            </label>
                            <label class="flex items-center space-x-2 text-sm">
                                <input type="checkbox" id="useCrossRef" checked class="rounded text-blue-600 focus:ring-blue-500">
                                <span>CrossRef</span>
                            </label>
                            <label class="flex items-center space-x-2 text-sm">
                                <input type="checkbox" id="useArxiv" checked class="rounded text-blue-600 focus:ring-blue-500">
                                <span>arXiv</span>
                            </label>
                            <label class="flex items-center space-x-2 text-sm">
                                <input type="checkbox" id="useOpenAlex" checked class="rounded text-blue-600 focus:ring-blue-500">
                                <span>OpenAlex</span>
                            </label>
                            <label class="flex items-center space-x-2 text-sm">
                                <input type="checkbox" id="useDOAJ" checked class="rounded text-blue-600 focus:ring-blue-500">
                                <span>DOAJ</span>
                            </label>
                            <label class="flex items-center space-x-2 text-sm">
                                <input type="checkbox" id="usePubMed" checked class="rounded text-blue-600 focus:ring-blue-500">
                                <span>PubMed Central</span>
                            </label>
                            <label class="flex items-center space-x-2 text-sm">
                                <input type="checkbox" id="useSSRN" class="rounded text-blue-600 focus:ring-blue-500" disabled title="SSRN requires API key authentication">
                                <span class="text-gray-400" title="SSRN requires API key authentication">SSRN (requires API key)</span>
                            </label>
                            <label class="flex items-center space-x-2 text-sm">
                                <input type="checkbox" id="usePhilPapers" checked class="rounded text-blue-600 focus:ring-blue-500">
                                <span>PhilPapers</span>
                            </label>
                            <label class="flex items-center space-x-2 text-sm">
                                <input type="checkbox" id="useCORE" class="rounded text-blue-600 focus:ring-blue-500" disabled title="CORE requires API key for v3">
                                <span class="text-gray-400" title="CORE requires API key for v3">CORE (requires API key)</span>
                            </label>
                            <label class="flex items-center space-x-2 text-sm">
                                <input type="checkbox" id="useUnpaywall" class="rounded text-blue-600 focus:ring-blue-500" disabled title="Unpaywall requires DOI lookup">
                                <span class="text-gray-400" title="Unpaywall requires DOI lookup">Unpaywall (DOI only)</span>
                            </label>
                            <label class="flex items-center space-x-2 text-sm">
                                <input type="checkbox" id="useIEEE" class="rounded text-blue-600 focus:ring-blue-500" disabled title="IEEE Xplore requires API key">
                                <span class="text-gray-400" title="IEEE Xplore requires API key">IEEE (requires API key)</span>
                            </label>
                        </div>
                    </div>

                    <!-- Additional Options -->
                    <div class="mt-4 grid grid-cols-2 md:grid-cols-4 gap-3">
                        <label class="flex items-center space-x-2 text-sm">
                            <input type="checkbox" id="includeDOI" checked class="rounded text-blue-600 focus:ring-blue-500">
                            <span>Include DOI</span>
                        </label>
                        <label class="flex items-center space-x-2 text-sm">
                            <input type="checkbox" id="includeAbstract" class="rounded text-blue-600 focus:ring-blue-500">
                            <span>Show abstracts</span>
                        </label>
                        <label class="flex items-center space-x-2 text-sm">
                            <input type="checkbox" id="sortByCitations" checked class="rounded text-blue-600 focus:ring-blue-500">
                            <span>Sort by citations</span>
                        </label>
                        <label class="flex items-center space-x-2 text-sm">
                            <input type="checkbox" id="requireDOI" checked class="rounded text-blue-600 focus:ring-blue-500">
                            <span>Require DOI</span>
                        </label>
                        <label class="flex items-center space-x-2 text-sm">
                            <input type="checkbox" id="showRelevanceScore" checked class="rounded text-blue-600 focus:ring-blue-500">
                            <span>Show relevance score</span>
                        </label>
                        <label class="flex items-center space-x-2 text-sm">
                            <input type="checkbox" id="showQualityMetrics" checked class="rounded text-blue-600 focus:ring-blue-500">
                            <span>Show quality metrics</span>
                        </label>
                        <label class="flex items-center space-x-2 text-sm">
                            <input type="checkbox" id="useSemanticMatching" checked class="rounded text-blue-600 focus:ring-blue-500">
                            <span>Semantic matching</span>
                        </label>
                        <label class="flex items-center space-x-2 text-sm">
                            <input type="checkbox" id="smartPlacement" checked class="rounded text-blue-600 focus:ring-blue-500">
                            <span>Smart placement</span>
                        </label>
                    </div>
                </div>

                <!-- Action Button -->
                <div class="flex items-center justify-center">
                    <button 
                        id="generateBtn"
                        onclick="generateRealCitations()" 
                        class="px-8 py-4 bg-gradient-to-r from-blue-600 to-indigo-600 text-white rounded-lg hover:from-blue-700 hover:to-indigo-700 transition duration-200 font-semibold text-lg shadow-lg hover:shadow-xl transform hover:scale-105">
                        <i class="fas fa-search mr-2"></i>
                        Find Real Citations from Academic APIs
                    </button>
                </div>
            </div>
        </div>

        <!-- Loading State -->
        <div id="loadingState" class="hidden bg-white rounded-xl shadow-lg p-8 mb-8">
            <div class="text-center mb-6">
                <div class="inline-block">
                    <div class="w-16 h-16 border-4 border-blue-200 border-t-blue-600 rounded-full animate-spin mx-auto mb-4"></div>
                    <p class="text-lg font-semibold text-gray-700">Searching Academic Databases...</p>
                    <p class="text-sm text-gray-500 mt-2" id="searchStatus">Analyzing sentences...</p>
                </div>
            </div>
            
            <div class="max-w-2xl mx-auto">
                <div class="search-progress">
                    <div class="flex justify-between text-sm mb-2">
                        <span class="font-medium text-gray-700">Progress</span>
                        <span class="text-gray-600"><span id="currentSentence">0</span> / <span id="totalSentences">0</span> sentences</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                    </div>
                </div>
                
                <div class="mt-4 space-y-2 text-sm">
                    <div class="flex items-center space-x-2" id="semanticScholarStatus">
                        <i class="fas fa-circle text-gray-400 text-xs"></i>
                        <span class="text-gray-600">Semantic Scholar: Waiting...</span>
                    </div>
                    <div class="flex items-center space-x-2" id="crossrefStatus">
                        <i class="fas fa-circle text-gray-400 text-xs"></i>
                        <span class="text-gray-600">CrossRef: Waiting...</span>
                    </div>
                    <div class="flex items-center space-x-2" id="arxivStatus">
                        <i class="fas fa-circle text-gray-400 text-xs"></i>
                        <span class="text-gray-600">arXiv: Waiting...</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Output Section -->
        <div id="outputSection" class="hidden">
            
            <!-- Statistics -->
            <div class="bg-white rounded-xl shadow-lg p-6 mb-6 no-print">
                <h3 class="text-lg font-semibold mb-4">
                    <i class="fas fa-chart-bar mr-2 text-green-600"></i>
                    Real Citation Statistics
                </h3>
                <div class="grid grid-cols-2 md:grid-cols-5 gap-4">
                    <div class="bg-blue-50 rounded-lg p-4 text-center">
                        <div class="text-3xl font-bold text-blue-600" id="stat-citations">0</div>
                        <div class="text-xs text-gray-600 mt-1">Total Citations</div>
                    </div>
                    <div class="bg-green-50 rounded-lg p-4 text-center">
                        <div class="text-3xl font-bold text-green-600" id="stat-sentences">0</div>
                        <div class="text-xs text-gray-600 mt-1">Cited Sentences</div>
                    </div>
                    <div class="bg-purple-50 rounded-lg p-4 text-center">
                        <div class="text-3xl font-bold text-purple-600" id="stat-sources">0</div>
                        <div class="text-xs text-gray-600 mt-1">Unique Papers</div>
                    </div>
                    <div class="bg-yellow-50 rounded-lg p-4 text-center">
                        <div class="text-3xl font-bold text-yellow-600" id="stat-dois">0</div>
                        <div class="text-xs text-gray-600 mt-1">Valid DOIs</div>
                    </div>
                    <div class="bg-indigo-50 rounded-lg p-4 text-center">
                        <div class="text-3xl font-bold text-indigo-600" id="stat-coverage">0%</div>
                        <div class="text-xs text-gray-600 mt-1">Coverage</div>
                    </div>
                </div>
            </div>

            <!-- Cited Text -->
            <div class="bg-white rounded-xl shadow-lg p-8 mb-6">
                <div class="flex items-center justify-between mb-6 no-print">
                    <h3 class="text-xl font-bold text-gray-900">
                        <i class="fas fa-file-alt mr-2 text-blue-600"></i>
                        Your Text with Real Citations
                    </h3>
                    <div class="flex space-x-2">
                        <button onclick="copyToClipboard()" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition text-sm">
                            <i class="fas fa-copy mr-2"></i>Copy
                        </button>
                        <button onclick="window.print()" class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition text-sm">
                            <i class="fas fa-print mr-2"></i>Print
                        </button>
                        <button onclick="exportToWord()" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition text-sm">
                            <i class="fas fa-file-word mr-2"></i>Export
                        </button>
                    </div>
                </div>
                
                <div id="citedText" class="prose max-w-none" style="font-family: 'Times New Roman', serif; line-height: 2; font-size: 16px;">
                    <!-- Cited text will appear here -->
                </div>
            </div>

            <!-- References List -->
            <div class="bg-white rounded-xl shadow-lg p-8">
                <h3 class="text-xl font-bold text-gray-900 mb-6">
                    <i class="fas fa-book mr-2 text-green-600"></i>
                    References (Real Academic Papers)
                    <span class="text-sm font-normal text-gray-500 ml-3" id="styleIndicator">APA 7th Edition</span>
                </h3>
                
                <div id="referencesList" class="space-y-3">
                    <!-- References will appear here -->
                </div>
            </div>
        </div>

    </div>

    <!-- Footer -->
    <footer class="bg-white border-t mt-16 py-6 no-print">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 text-center text-sm text-gray-600">
            <p><strong>Real Academic Citations</strong> powered by free APIs</p>
            <p class="mt-2 text-xs text-gray-500">
                <i class="fas fa-database mr-1"></i>
                Semantic Scholar â€¢ CrossRef â€¢ arXiv - All citations are from real published papers with verified DOI links
            </p>
        </div>
    </footer>

    <script>
        // Global state
        let citations = [];
        let references = [];
        let citedSentences = [];

        // Character and sentence counter
        document.getElementById('inputText').addEventListener('input', function(e) {
            const text = e.target.value;
            document.getElementById('charCount').textContent = text.length;
            
            const sentences = splitIntoSentences(text);
            document.getElementById('sentenceCount').textContent = sentences.length;
        });

        // Toggle API config
        function toggleAPIConfig() {
            const config = document.getElementById('apiConfig');
            config.classList.toggle('hidden');
        }

        // Clear input
        function clearInput() {
            document.getElementById('inputText').value = '';
            document.getElementById('charCount').textContent = '0';
            document.getElementById('sentenceCount').textContent = '0';
        }

        // Split text into sentences
        function splitIntoSentences(text) {
            // Split on sentence-ending punctuation (., !, ?)
            // This regex captures sentences while preserving the punctuation separately
            const sentencePattern = /([^.!?]*[.!?])/g;
            const matches = text.match(sentencePattern) || [];
            
            return matches
                .map(s => s.trim())
                .filter(s => s.length > 10)  // Only keep sentences longer than 10 characters
                .map(s => {
                    // Remove trailing punctuation for processing, but keep track of it
                    const punctuation = s.match(/[.!?]$/)?.[0] || '.';
                    const sentenceText = s.replace(/[.!?]$/, '').trim();
                    return { text: sentenceText, punctuation: punctuation };
                });
        }

        // Group sentences into semantic chunks for better citation handling
        function groupIntoSemanticChunks(sentences) {
            // This function groups related sentences together based on:
            // 1. Length (min ~60 words per chunk for meaningful context)
            // 2. Coherence (same topic/subject)
            // 3. Natural paragraph breaks
            
            const chunks = [];
            let currentChunk = [];
            let wordCount = 0;
            const wordsPerChunk = 60; // Minimum words per semantic chunk
            
            sentences.forEach((sentence, index) => {
                const sentenceWords = sentence.text.split(/\s+/).length;
                
                currentChunk.push(sentence);
                wordCount += sentenceWords;
                
                // Create chunk if:
                // 1. Word count exceeds threshold AND (next is last sentence OR has period)
                // 2. This is the last sentence
                // 3. Paragraph break detected (sentences usually break with numbers/headings)
                const isLastSentence = index === sentences.length - 1;
                const hasHeadingNumber = /^\d+\.\d+/.test(sentences[index + 1]?.text || '');
                const shouldBreak = wordCount >= wordsPerChunk || isLastSentence || hasHeadingNumber;
                
                if (shouldBreak && currentChunk.length > 0) {
                    chunks.push({
                        sentences: currentChunk,
                        text: currentChunk.map(s => s.text + s.punctuation).join(' '),
                        wordCount: wordCount
                    });
                    currentChunk = [];
                    wordCount = 0;
                }
            });
            
            // Handle any remaining sentences
            if (currentChunk.length > 0) {
                chunks.push({
                    sentences: currentChunk,
                    text: currentChunk.map(s => s.text + s.punctuation).join(' '),
                    wordCount: wordCount
                });
            }
            
            return chunks;
        }

        // Main function to generate REAL citations
        async function generateRealCitations() {
            const inputText = document.getElementById('inputText').value.trim();
            
            if (!inputText) {
                alert('Please paste your text first');
                return;
            }

            // Validate at least one API source is selected
            const useSemanticScholar = document.getElementById('useSemanticScholar').checked;
            const useCrossRef = document.getElementById('useCrossRef').checked;
            const useArxiv = document.getElementById('useArxiv').checked;
            
            if (!useSemanticScholar && !useCrossRef && !useArxiv) {
                alert('Please select at least one API source');
                return;
            }

            // Show loading state
            document.getElementById('loadingState').classList.remove('hidden');
            document.getElementById('outputSection').classList.add('hidden');
            document.getElementById('generateBtn').disabled = true;

            try {
                // Split text into sentences
                const sentences = splitIntoSentences(inputText);
                
                // Group sentences into semantic chunks
                const semanticChunks = groupIntoSemanticChunks(sentences);
                document.getElementById('totalSentences').textContent = semanticChunks.length;
                
                // Initialize
                citedSentences = [];
                references = [];
                citations = [];
                
                // Process each semantic chunk
                for (let i = 0; i < semanticChunks.length; i++) {
                    const chunk = semanticChunks[i];
                    
                    // Update progress
                    updateProgress(i + 1, semanticChunks.length, `Processing semantic chunk ${i + 1}...`);
                    
                    // Search for relevant papers using the entire chunk as query
                    const papers = await searchRealPapers(chunk);
                    
                    if (papers.length > 0) {
                        const citationNumbers = [];
                        const maxCitations = parseInt(document.getElementById('citationsPerSentence').value);
                        
                        for (let j = 0; j < Math.min(papers.length, maxCitations); j++) {
                            const paper = papers[j];
                            let refIndex = references.findIndex(r => 
                                (r.doi && paper.doi && r.doi === paper.doi) || 
                                (r.title === paper.title)
                            );
                            
                            if (refIndex === -1) {
                                references.push(paper);
                                refIndex = references.length - 1;
                            }
                            
                            citationNumbers.push(refIndex + 1);
                        }
                        
                        citedSentences.push({
                            text: chunk.text,
                            citations: citationNumbers,
                            isChunk: true,
                            sentenceCount: chunk.sentences.length
                        });
                    } else {
                        citedSentences.push({
                            text: chunk.text,
                            citations: [],
                            isChunk: true,
                            sentenceCount: chunk.sentences.length
                        });
                    }
                    
                    // Small delay to avoid rate limiting
                    await new Promise(resolve => setTimeout(resolve, 300));
                }

                // Display results
                displayCitedText();
                displayReferences();
                updateStatistics();

                // Show output section
                document.getElementById('loadingState').classList.add('hidden');
                document.getElementById('outputSection').classList.remove('hidden');
                
                // Scroll to results
                document.getElementById('outputSection').scrollIntoView({ behavior: 'smooth' });

            } catch (error) {
                console.error('Error generating citations:', error);
                alert('An error occurred while generating citations. Please try again.');
            } finally {
                document.getElementById('generateBtn').disabled = false;
            }
        }

        // Update progress bar
        function updateProgress(current, total, status) {
            document.getElementById('currentSentence').textContent = current;
            document.getElementById('searchStatus').textContent = status;
            const percentage = (current / total) * 100;
            document.getElementById('progressFill').style.width = percentage + '%';
        }

        // Update API status
        function updateAPIStatus(api, status, message) {
            const statusEl = document.getElementById(`${api}Status`);
            const icon = statusEl.querySelector('i');
            const text = statusEl.querySelector('span');
            
            if (status === 'searching') {
                icon.className = 'fas fa-spinner fa-spin text-blue-500 text-xs';
                text.textContent = `${api}: ${message}`;
                text.className = 'text-blue-600 font-medium';
            } else if (status === 'success') {
                icon.className = 'fas fa-check-circle text-green-500 text-xs';
                text.textContent = `${api}: ${message}`;
                text.className = 'text-green-600';
            } else if (status === 'error') {
                icon.className = 'fas fa-exclamation-circle text-red-500 text-xs';
                text.textContent = `${api}: ${message}`;
                text.className = 'text-red-600';
            }
        }

        // Search real academic papers from APIs
        async function searchRealPapers(queryInput) {
            const papers = [];
            
            // Handle both sentence objects and chunk objects
            let queryText = '';
            if (typeof queryInput === 'string') {
                queryText = queryInput;
            } else if (queryInput.text) {
                queryText = queryInput.text;
            } else {
                queryText = '';
            }
            
            const useSemanticScholar = document.getElementById('useSemanticScholar').checked;
            const useCrossRef = document.getElementById('useCrossRef').checked;
            const useArxiv = document.getElementById('useArxiv').checked;
            const useOpenAlex = document.getElementById('useOpenAlex').checked;
            const useDOAJ = document.getElementById('useDOAJ').checked;
            const usePubMed = document.getElementById('usePubMed').checked;
            const useSSRN = document.getElementById('useSSRN').checked;
            const usePhilPapers = document.getElementById('usePhilPapers').checked;
            const useCORE = document.getElementById('useCORE').checked;
            const useUnpaywall = document.getElementById('useUnpaywall').checked;
            const useIEEE = document.getElementById('useIEEE').checked;
            const requireDOI = document.getElementById('requireDOI').checked;
            const sortByCitations = document.getElementById('sortByCitations').checked;
            const useSemanticMatching = document.getElementById('useSemanticMatching').checked;
            const yearRange = document.getElementById('yearRange').value;
            
            // Calculate year filter
            const currentYear = new Date().getFullYear();
            const minYear = yearRange === 'all' ? 1900 : currentYear - parseInt(yearRange);
            
            // Extract keywords from text
            const keywords = extractKeywords(queryText);
            const searchQuery = keywords.join(' ');
            
            if (!searchQuery) {
                return [];
            }
            
            // Search Semantic Scholar
            if (useSemanticScholar && searchQuery) {
                updateAPIStatus('semanticScholar', 'searching', 'Searching...');
                try {
                    const semanticPapers = await searchSemanticScholar(searchQuery, minYear);
                    papers.push(...semanticPapers);
                    updateAPIStatus('semanticScholar', 'success', `Found ${semanticPapers.length} papers`);
                } catch (error) {
                    console.error('Semantic Scholar error:', error);
                    updateAPIStatus('semanticScholar', 'error', 'Error occurred');
                }
            }
            
            // Search CrossRef
            if (useCrossRef && searchQuery) {
                updateAPIStatus('crossref', 'searching', 'Searching...');
                try {
                    const crossrefPapers = await searchCrossRef(searchQuery, minYear);
                    papers.push(...crossrefPapers);
                    updateAPIStatus('crossref', 'success', `Found ${crossrefPapers.length} papers`);
                } catch (error) {
                    console.error('CrossRef error:', error);
                    updateAPIStatus('crossref', 'error', 'Error occurred');
                }
            }
            
            // Search arXiv
            if (useArxiv && searchQuery) {
                updateAPIStatus('arxiv', 'searching', 'Searching...');
                try {
                    const arxivPapers = await searchArxiv(searchQuery);
                    papers.push(...arxivPapers);
                    updateAPIStatus('arxiv', 'success', `Found ${arxivPapers.length} papers`);
                } catch (error) {
                    console.error('arXiv error:', error);
                    updateAPIStatus('arxiv', 'error', 'Error occurred');
                }
            }
            
            // Search OpenAlex
            if (useOpenAlex && searchQuery) {
                try {
                    const openAlexPapers = await searchOpenAlex(searchQuery, minYear);
                    papers.push(...openAlexPapers);
                } catch (error) {
                    console.error('OpenAlex error:', error);
                }
            }
            
            // Search DOAJ
            if (useDOAJ && searchQuery) {
                try {
                    const doajPapers = await searchDOAJ(searchQuery, minYear);
                    papers.push(...doajPapers);
                } catch (error) {
                    console.error('DOAJ error:', error);
                }
            }
            
            // Search PubMed Central
            if (usePubMed && searchQuery) {
                try {
                    const pubmedPapers = await searchPubMed(searchQuery, minYear);
                    papers.push(...pubmedPapers);
                } catch (error) {
                    console.error('PubMed error:', error);
                }
            }
            
            // Search SSRN
            if (useSSRN && searchQuery) {
                try {
                    const ssrnPapers = await searchSSRN(searchQuery, minYear);
                    papers.push(...ssrnPapers);
                } catch (error) {
                    console.error('SSRN error:', error);
                }
            }
            
            // Search PhilPapers
            if (usePhilPapers && searchQuery) {
                try {
                    const philPapers = await searchPhilPapers(searchQuery, minYear);
                    papers.push(...philPapers);
                } catch (error) {
                    console.error('PhilPapers error:', error);
                }
            }
            
            // Search CORE
            if (useCORE && searchQuery) {
                try {
                    const corePapers = await searchCORE(searchQuery, minYear);
                    papers.push(...corePapers);
                } catch (error) {
                    console.error('CORE error:', error);
                }
            }
            
            // Search Unpaywall
            if (useUnpaywall && searchQuery) {
                try {
                    const unpaywallPapers = await searchUnpaywall(searchQuery, minYear);
                    papers.push(...unpaywallPapers);
                } catch (error) {
                    console.error('Unpaywall error:', error);
                }
            }
            
            // Search IEEE
            if (useIEEE && searchQuery) {
                try {
                    const ieeePapers = await searchIEEE(searchQuery, minYear);
                    papers.push(...ieeePapers);
                } catch (error) {
                    console.error('IEEE error:', error);
                }
            }
            
            // Filter papers
            let filteredPapers = papers;
            
            // Remove duplicates by DOI or title
            filteredPapers = filteredPapers.filter((paper, index, self) => 
                index === self.findIndex(p => 
                    (p.doi && paper.doi && p.doi === paper.doi) ||
                    (!p.doi && !paper.doi && p.title === paper.title)
                )
            );
            
            // Calculate relevance scores if semantic matching is enabled
            if (useSemanticMatching) {
                filteredPapers = filteredPapers.map(paper => {
                    const relevanceScore = calculateRelevanceScore(queryText, paper);
                    const credibilityScore = calculateCredibilityScore(paper);
                    const freshnessScore = calculateFreshnessScore(paper.year);
                    
                    return {
                        ...paper,
                        relevanceScore,
                        credibilityScore,
                        freshnessScore,
                        overallScore: (relevanceScore * 0.5) + (credibilityScore * 0.3) + (freshnessScore * 0.2)
                    };
                });
                
                // Sort by overall score
                filteredPapers.sort((a, b) => b.overallScore - a.overallScore);
            } else {
                // Sort by citation count if selected
                if (sortByCitations) {
                    filteredPapers.sort((a, b) => (b.citationCount || 0) - (a.citationCount || 0));
                }
            }
            
            // Require DOI if selected
            if (requireDOI) {
                filteredPapers = filteredPapers.filter(p => p.doi);
            }
            
            return filteredPapers;
        }

        // Calculate relevance score using TF-IDF-like approach
        function calculateRelevanceScore(query, paper) {
            const queryTerms = extractKeywords(query.toLowerCase());
            const paperText = `${paper.title} ${paper.abstract || ''}`.toLowerCase();
            
            let score = 0;
            let matches = 0;
            
            queryTerms.forEach(term => {
                const termCount = (paperText.match(new RegExp(term, 'g')) || []).length;
                if (termCount > 0) {
                    matches++;
                    // TF-IDF simplified: term frequency with diminishing returns
                    score += Math.log(1 + termCount) * 10;
                }
            });
            
            // Boost score based on match percentage
            const matchPercentage = queryTerms.length > 0 ? matches / queryTerms.length : 0;
            score = score * (1 + matchPercentage);
            
            // Normalize to 0-100
            return Math.min(100, Math.round(score));
        }

        // Calculate credibility score based on citation count
        function calculateCredibilityScore(paper) {
            const citations = paper.citationCount || 0;
            
            // Logarithmic scale for citations
            if (citations === 0) return 30;
            if (citations < 10) return 40 + citations * 2;
            if (citations < 100) return 60 + Math.log10(citations) * 10;
            return Math.min(100, 80 + Math.log10(citations / 10) * 10);
        }

        // Calculate freshness score based on publication year
        function calculateFreshnessScore(year) {
            const currentYear = new Date().getFullYear();
            const age = currentYear - year;
            
            if (age < 0) return 50; // Future publication
            if (age === 0) return 100; // Current year
            if (age === 1) return 95;
            if (age <= 3) return 90;
            if (age <= 5) return 80;
            if (age <= 10) return 60;
            if (age <= 20) return 40;
            return Math.max(10, 40 - age);
        }

        // Extract keywords from sentence
        function extractKeywords(sentence) {
            // Remove common words and extract meaningful terms
            const commonWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'from', 'has', 'have', 'had', 'is', 'are', 'was', 'were', 'been', 'be', 'being', 'can', 'could', 'may', 'might', 'will', 'would', 'should', 'this', 'that', 'these', 'those'];
            const words = sentence.toLowerCase()
                .replace(/[^\w\s]/g, '')
                .split(/\s+/)
                .filter(word => word.length > 3 && !commonWords.includes(word));
            
            // Take top 5 most relevant words
            return words.slice(0, 5);
        }

        // Search Semantic Scholar API
        async function searchSemanticScholar(query, minYear) {
            try {
                const apiKey = document.getElementById('semanticScholarKey').value;
                const headers = {
                    'Content-Type': 'application/json'
                };
                if (apiKey) {
                    headers['x-api-key'] = apiKey;
                }
                
                const url = `https://api.semanticscholar.org/graph/v1/paper/search?query=${encodeURIComponent(query)}&limit=5&fields=title,authors,year,venue,citationCount,externalIds,abstract,publicationDate`;
                
                const response = await fetch(url, { headers });
                
                if (!response.ok) {
                    throw new Error(`Semantic Scholar API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                return (data.data || [])
                    .filter(paper => paper.year >= minYear)
                    .map(paper => ({
                        title: paper.title,
                        authors: (paper.authors || []).map(a => [a.name.split(' ').pop(), a.name.split(' ')[0]]),
                        year: paper.year,
                        journal: paper.venue || 'Conference Paper',
                        doi: paper.externalIds?.DOI,
                        url: paper.externalIds?.DOI ? `https://doi.org/${paper.externalIds.DOI}` : null,
                        citationCount: paper.citationCount || 0,
                        abstract: paper.abstract,
                        source: 'Semantic Scholar'
                    }))
                    .filter(paper => paper.title && paper.authors.length > 0);
            } catch (error) {
                console.error('Semantic Scholar search error:', error);
                return [];
            }
        }

        // Search CrossRef API
        async function searchCrossRef(query, minYear) {
            try {
                const email = document.getElementById('crossrefEmail').value;
                const mailto = email ? `&mailto=${encodeURIComponent(email)}` : '';
                
                const url = `https://api.crossref.org/works?query=${encodeURIComponent(query)}&rows=5&filter=from-pub-date:${minYear}${mailto}`;
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`CrossRef API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                return (data.message.items || [])
                    .map(paper => {
                        const pubDate = paper.published?.['date-parts']?.[0];
                        const year = pubDate ? pubDate[0] : null;
                        
                        return {
                            title: paper.title?.[0],
                            authors: (paper.author || []).map(a => [a.family || '', a.given || '']),
                            year: year,
                            journal: paper['container-title']?.[0] || 'Journal',
                            volume: paper.volume,
                            issue: paper.issue,
                            pages: paper.page,
                            doi: paper.DOI,
                            url: paper.DOI ? `https://doi.org/${paper.DOI}` : null,
                            citationCount: paper['is-referenced-by-count'] || 0,
                            abstract: paper.abstract,
                            source: 'CrossRef'
                        };
                    })
                    .filter(paper => paper.title && paper.year && paper.authors.length > 0);
            } catch (error) {
                console.error('CrossRef search error:', error);
                return [];
            }
        }

        // Search arXiv API
        async function searchArxiv(query) {
            try {
                const url = `https://export.arxiv.org/api/query?search_query=all:${encodeURIComponent(query)}&start=0&max_results=5`;
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`arXiv API error: ${response.status}`);
                }
                
                const text = await response.text();
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, 'text/xml');
                
                const entries = xml.querySelectorAll('entry');
                const papers = [];
                
                entries.forEach(entry => {
                    const title = entry.querySelector('title')?.textContent.trim();
                    const authors = Array.from(entry.querySelectorAll('author name')).map(a => {
                        const name = a.textContent.trim();
                        const parts = name.split(' ');
                        return [parts[parts.length - 1], parts[0]];
                    });
                    const published = entry.querySelector('published')?.textContent;
                    const year = published ? new Date(published).getFullYear() : null;
                    const summary = entry.querySelector('summary')?.textContent.trim();
                    const id = entry.querySelector('id')?.textContent;
                    const arxivId = id ? id.split('/').pop() : null;
                    
                    if (title && authors.length > 0 && year) {
                        papers.push({
                            title: title,
                            authors: authors,
                            year: year,
                            journal: 'arXiv preprint',
                            doi: null,
                            url: id,
                            arxivId: arxivId,
                            citationCount: 0,
                            abstract: summary,
                            source: 'arXiv'
                        });
                    }
                });
                
                return papers;
            } catch (error) {
                console.error('arXiv search error:', error);
                return [];
            }
        }

        // Search OpenAlex API
        async function searchOpenAlex(query, minYear) {
            try {
                const url = `https://api.openalex.org/works?search=${encodeURIComponent(query)}&filter=publication_year:${minYear}-&per-page=5`;
                
                const response = await fetch(url, {
                    headers: { 'User-Agent': 'mailto:citation-generator@example.com' }
                });
                
                if (!response.ok) {
                    throw new Error(`OpenAlex API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                return (data.results || [])
                    .map(paper => {
                        const year = paper.publication_year;
                        const authorships = paper.authorships || [];
                        
                        return {
                            title: paper.title,
                            authors: authorships.map(a => {
                                const name = a.author?.display_name || '';
                                const parts = name.split(' ');
                                return [parts[parts.length - 1], parts[0]];
                            }),
                            year: year,
                            journal: paper.primary_location?.source?.display_name || 'Journal',
                            doi: paper.doi?.replace('https://doi.org/', ''),
                            url: paper.doi,
                            citationCount: paper.cited_by_count || 0,
                            abstract: paper.abstract_inverted_index ? 'Available' : null,
                            openAccess: paper.open_access?.is_oa || false,
                            source: 'OpenAlex'
                        };
                    })
                    .filter(paper => paper.title && paper.authors.length > 0);
            } catch (error) {
                console.error('OpenAlex search error:', error);
                return [];
            }
        }

        // Search DOAJ API
        async function searchDOAJ(query, minYear) {
            try {
                const url = `https://doaj.org/api/search/articles/${encodeURIComponent(query)}?pageSize=5`;
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`DOAJ API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                return (data.results || [])
                    .map(paper => {
                        const bibjson = paper.bibjson || {};
                        const year = bibjson.year ? parseInt(bibjson.year) : null;
                        
                        if (!year || year < minYear) return null;
                        
                        return {
                            title: bibjson.title,
                            authors: (bibjson.author || []).map(a => {
                                const name = a.name || '';
                                const parts = name.split(' ');
                                return [parts[parts.length - 1], parts[0]];
                            }),
                            year: year,
                            journal: bibjson.journal?.title || 'Open Access Journal',
                            doi: bibjson.identifier?.find(i => i.type === 'doi')?.id,
                            url: bibjson.identifier?.find(i => i.type === 'doi')?.id ? 
                                `https://doi.org/${bibjson.identifier.find(i => i.type === 'doi').id}` : null,
                            citationCount: 0,
                            abstract: bibjson.abstract,
                            openAccess: true,
                            source: 'DOAJ'
                        };
                    })
                    .filter(paper => paper && paper.title && paper.authors.length > 0);
            } catch (error) {
                console.error('DOAJ search error:', error);
                return [];
            }
        }

        // Search PubMed Central API
        async function searchPubMed(query, minYear) {
            try {
                // First search for IDs
                const searchUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pmc&term=${encodeURIComponent(query)}&retmode=json&retmax=5&mindate=${minYear}&datetype=pdat`;
                
                const searchResponse = await fetch(searchUrl);
                
                if (!searchResponse.ok) {
                    throw new Error(`PubMed search error: ${searchResponse.status}`);
                }
                
                const searchData = await searchResponse.json();
                const ids = searchData.esearchresult?.idlist || [];
                
                if (ids.length === 0) return [];
                
                // Fetch paper details
                const summaryUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?db=pmc&id=${ids.join(',')}&retmode=json`;
                
                const summaryResponse = await fetch(summaryUrl);
                
                if (!summaryResponse.ok) {
                    throw new Error(`PubMed summary error: ${summaryResponse.status}`);
                }
                
                const summaryData = await summaryResponse.json();
                const papers = [];
                
                for (const id of ids) {
                    const paper = summaryData.result?.[id];
                    if (!paper) continue;
                    
                    const year = paper.pubdate ? parseInt(paper.pubdate.split(' ')[0]) : null;
                    const authors = (paper.authors || []).map(a => {
                        const name = a.name || '';
                        const parts = name.split(' ');
                        return [parts[parts.length - 1], parts[0]];
                    });
                    
                    papers.push({
                        title: paper.title,
                        authors: authors,
                        year: year,
                        journal: paper.fulljournalname || 'PubMed Central',
                        doi: paper.articleids?.find(a => a.idtype === 'doi')?.value,
                        url: paper.articleids?.find(a => a.idtype === 'doi')?.value ?
                            `https://doi.org/${paper.articleids.find(a => a.idtype === 'doi').value}` :
                            `https://www.ncbi.nlm.nih.gov/pmc/articles/PMC${id}/`,
                        citationCount: 0,
                        abstract: null,
                        openAccess: true,
                        source: 'PubMed Central'
                    });
                }
                
                return papers.filter(paper => paper.title && paper.authors.length > 0);
            } catch (error) {
                console.error('PubMed search error:', error);
                return [];
            }
        }

        // Search SSRN API (limited public access - using basic search)
        async function searchSSRN(query, minYear) {
            try {
                // SSRN doesn't have a free public API, so we'll return empty for now
                // This would require API key or scraping which isn't recommended
                console.log('SSRN API requires authentication - skipping');
                return [];
            } catch (error) {
                console.error('SSRN search error:', error);
                return [];
            }
        }

        // Search PhilPapers API
        async function searchPhilPapers(query, minYear) {
            try {
                const url = `https://philpapers.org/api/search.json?terms=${encodeURIComponent(query)}&limit=5`;
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`PhilPapers API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                return (data.results || [])
                    .map(paper => {
                        const year = paper.pubYear ? parseInt(paper.pubYear) : null;
                        
                        if (!year || year < minYear) return null;
                        
                        return {
                            title: paper.title,
                            authors: (paper.authors || []).map(a => {
                                const name = a.name || a;
                                const parts = typeof name === 'string' ? name.split(' ') : [name];
                                return [parts[parts.length - 1], parts[0]];
                            }),
                            year: year,
                            journal: paper.venue || 'Philosophy Journal',
                            doi: paper.doi,
                            url: paper.doi ? `https://doi.org/${paper.doi}` : paper.url,
                            citationCount: 0,
                            abstract: paper.abstract,
                            source: 'PhilPapers'
                        };
                    })
                    .filter(paper => paper && paper.title && paper.authors.length > 0);
            } catch (error) {
                console.error('PhilPapers search error:', error);
                return [];
            }
        }

        // Search CORE API
        async function searchCORE(query, minYear) {
            try {
                // CORE API v3 requires API key, using limited public endpoint
                const url = `https://core.ac.uk/api-v2/search/${encodeURIComponent(query)}?page=1&pageSize=5`;
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    console.log('CORE API requires authentication - skipping');
                    return [];
                }
                
                const data = await response.json();
                
                return (data.data || [])
                    .map(paper => {
                        const year = paper.yearPublished ? parseInt(paper.yearPublished) : null;
                        
                        if (!year || year < minYear) return null;
                        
                        return {
                            title: paper.title,
                            authors: (paper.authors || []).map(a => {
                                const name = typeof a === 'string' ? a : a.name || '';
                                const parts = name.split(' ');
                                return [parts[parts.length - 1], parts[0]];
                            }),
                            year: year,
                            journal: paper.publisher || 'Research Repository',
                            doi: paper.doi,
                            url: paper.doi ? `https://doi.org/${paper.doi}` : paper.downloadUrl,
                            citationCount: 0,
                            abstract: paper.description,
                            openAccess: true,
                            source: 'CORE'
                        };
                    })
                    .filter(paper => paper && paper.title && paper.authors.length > 0);
            } catch (error) {
                console.error('CORE search error:', error);
                return [];
            }
        }

        // Search Unpaywall API
        async function searchUnpaywall(query, minYear) {
            try {
                // Unpaywall requires DOI lookup, not general search
                // This is better used as a supplement to other APIs
                console.log('Unpaywall requires DOI - use as supplement only');
                return [];
            } catch (error) {
                console.error('Unpaywall search error:', error);
                return [];
            }
        }

        // Search IEEE Xplore API
        async function searchIEEE(query, minYear) {
            try {
                // IEEE Xplore requires API key for most access
                console.log('IEEE Xplore API requires authentication - skipping');
                return [];
            } catch (error) {
                console.error('IEEE search error:', error);
                return [];
            }
        }

        // Display cited text
        function displayCitedText() {
            const citedTextDiv = document.getElementById('citedText');
            citedTextDiv.innerHTML = '';
            
            citedSentences.forEach((citedItem, index) => {
                const itemEl = document.createElement('div');
                itemEl.className = 'cited-sentence';
                
                let itemHTML = citedItem.text;
                
                // Add citation numbers after the text
                if (citedItem.citations && citedItem.citations.length > 0) {
                    citedItem.citations.forEach(citationNum => {
                        itemHTML += `<sup class="citation-number" onclick="scrollToReference(${citationNum})" style="cursor: pointer;">[${citationNum}]</sup>`;
                    });
                } else if (citedItem.isChunk) {
                    // Show indicator that no citations found
                    itemHTML += ` <span class="text-sm text-gray-400" title="No citations found for this section">[no citations]</span>`;
                }
                
                itemEl.innerHTML = itemHTML;
                citedTextDiv.appendChild(itemEl);
                
                // Add paragraph break after chunk
                const spacer = document.createElement('div');
                spacer.style.height = '12px';
                citedTextDiv.appendChild(spacer);
            });
        }

        // Display references
        function displayReferences() {
            const container = document.getElementById('referencesList');
            const style = document.getElementById('citationStyle').value;
            const includeDOI = document.getElementById('includeDOI').checked;
            const includeAbstract = document.getElementById('includeAbstract').checked;
            const showQualityMetrics = document.getElementById('showQualityMetrics').checked;
            const showRelevanceScore = document.getElementById('showRelevanceScore').checked;
            
            let html = '';
            references.forEach((paper, index) => {
                const formattedRef = formatReference(paper, style);
                
                const doiHtml = includeDOI && paper.doi ? 
                    `<div class="mt-2">
                        <i class="fas fa-link text-green-600 mr-2"></i>
                        <a href="${paper.url}" target="_blank" class="doi-link">
                            https://doi.org/${paper.doi}
                            <i class="fas fa-external-link-alt text-xs"></i>
                        </a>
                    </div>` : '';
                
                const arxivHtml = paper.arxivId && !paper.doi ?
                    `<div class="mt-2">
                        <i class="fas fa-file-alt text-blue-600 mr-2"></i>
                        <a href="${paper.url}" target="_blank" class="doi-link">
                            arXiv:${paper.arxivId}
                            <i class="fas fa-external-link-alt text-xs"></i>
                        </a>
                    </div>` : '';
                
                const abstractHtml = includeAbstract && paper.abstract ?
                    `<div class="mt-2 text-sm text-gray-600 italic bg-gray-50 p-3 rounded">
                        ${paper.abstract.substring(0, 200)}${paper.abstract.length > 200 ? '...' : ''}
                    </div>` : '';
                
                // Quality Metrics
                let metricsHtml = '';
                if (showQualityMetrics && (paper.relevanceScore || paper.credibilityScore || paper.freshnessScore)) {
                    metricsHtml = `
                        <div class="mt-3 flex flex-wrap gap-2">
                            ${showRelevanceScore && paper.relevanceScore ? 
                                `<span class="inline-flex items-center px-2 py-1 bg-blue-100 text-blue-700 rounded text-xs font-medium">
                                    <i class="fas fa-star mr-1"></i>Relevance: ${paper.relevanceScore}%
                                </span>` : ''}
                            ${paper.credibilityScore ? 
                                `<span class="inline-flex items-center px-2 py-1 bg-purple-100 text-purple-700 rounded text-xs font-medium">
                                    <i class="fas fa-certificate mr-1"></i>Credibility: ${paper.credibilityScore}%
                                </span>` : ''}
                            ${paper.freshnessScore ? 
                                `<span class="inline-flex items-center px-2 py-1 bg-green-100 text-green-700 rounded text-xs font-medium">
                                    <i class="fas fa-clock mr-1"></i>Freshness: ${paper.freshnessScore}%
                                </span>` : ''}
                            ${paper.citationCount ? 
                                `<span class="inline-flex items-center px-2 py-1 bg-yellow-100 text-yellow-700 rounded text-xs font-medium">
                                    <i class="fas fa-quote-right mr-1"></i>${paper.citationCount} citations
                                </span>` : ''}
                            ${paper.openAccess ? 
                                `<span class="inline-flex items-center px-2 py-1 bg-emerald-100 text-emerald-700 rounded text-xs font-medium">
                                    <i class="fas fa-unlock mr-1"></i>Open Access
                                </span>` : ''}
                        </div>
                    `;
                }
                
                const sourceHtml = `<span class="text-xs text-gray-500 ml-2">(Source: ${paper.source})</span>`;
                
                html += `
                    <div class="reference-card" id="ref-${index + 1}">
                        <div class="flex items-start">
                            <div class="bg-blue-100 text-blue-700 font-bold rounded-full w-8 h-8 flex items-center justify-center mr-4 flex-shrink-0">
                                ${index + 1}
                            </div>
                            <div class="flex-1">
                                <div class="text-gray-800" style="line-height: 1.6;">
                                    ${formattedRef}
                                    ${sourceHtml}
                                </div>
                                ${doiHtml}
                                ${arxivHtml}
                                ${metricsHtml}
                                ${abstractHtml}
                            </div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html || '<p class="text-gray-500">No references found.</p>';
        }

        // Format reference based on citation style
        function formatReference(paper, style) {
            const authorsText = formatAuthors(paper.authors, style);
            const volumeInfo = paper.volume ? `, <em>${paper.volume}</em>` : '';
            const issueInfo = paper.issue ? `(${paper.issue})` : '';
            const pagesInfo = paper.pages ? `, ${paper.pages}` : '';
            
            switch(style) {
                case 'apa':
                    return `${authorsText} (${paper.year}). ${paper.title}. <em>${paper.journal}</em>${volumeInfo}${issueInfo}${pagesInfo}.`;
                
                case 'mla':
                    return `${authorsText}. "${paper.title}." <em>${paper.journal}</em>${volumeInfo ? ', vol. ' + paper.volume : ''}${issueInfo ? ', no. ' + paper.issue : ''}, ${paper.year}${pagesInfo ? ', pp. ' + paper.pages : ''}.`;
                
                case 'chicago':
                    return `${authorsText}. "${paper.title}." <em>${paper.journal}</em> ${paper.volume}${issueInfo ? ', no. ' + paper.issue : ''} (${paper.year})${pagesInfo ? ': ' + paper.pages : ''}.`;
                
                case 'harvard':
                    return `${authorsText}, ${paper.year}. ${paper.title}. <em>${paper.journal}</em>${volumeInfo}${issueInfo}${pagesInfo}.`;
                
                case 'ieee':
                    return `${authorsText}, "${paper.title}," <em>${paper.journal}</em>${volumeInfo ? ', vol. ' + paper.volume : ''}${issueInfo ? ', no. ' + paper.issue : ''}${pagesInfo ? ', pp. ' + paper.pages : ''}, ${paper.year}.`;
                
                case 'vancouver':
                    return `${authorsText}. ${paper.title}. ${paper.journal}. ${paper.year}${volumeInfo ? ';' + paper.volume : ''}${issueInfo}${pagesInfo ? ':' + paper.pages : ''}.`;
                
                default:
                    return `${authorsText} (${paper.year}). ${paper.title}. ${paper.journal}.`;
            }
        }

        // Format authors based on style
        function formatAuthors(authors, style) {
            if (!authors || authors.length === 0) return 'Unknown';
            
            const formatAuthor = (author, isFirst = false) => {
                const [lastName, firstName] = author;
                const initial = firstName ? firstName.charAt(0) + '.' : '';
                
                switch(style) {
                    case 'apa':
                    case 'chicago':
                    case 'harvard':
                        return `${lastName}, ${initial}`;
                    case 'mla':
                        return isFirst ? `${lastName}, ${firstName}` : `${firstName} ${lastName}`;
                    case 'ieee':
                    case 'vancouver':
                        return `${initial} ${lastName}`;
                    default:
                        return `${lastName}, ${initial}`;
                }
            };
            
            if (authors.length === 1) {
                return formatAuthor(authors[0], true);
            } else if (authors.length === 2) {
                if (style === 'apa') {
                    return `${formatAuthor(authors[0], true)}, & ${formatAuthor(authors[1])}`;
                } else {
                    return `${formatAuthor(authors[0], true)}, ${formatAuthor(authors[1])}`;
                }
            } else if (authors.length <= 7) {
                const formattedAuthors = authors.map((a, i) => formatAuthor(a, i === 0));
                if (style === 'apa') {
                    return formattedAuthors.slice(0, -1).join(', ') + ', & ' + formattedAuthors[formattedAuthors.length - 1];
                } else {
                    return formattedAuthors.join(', ');
                }
            } else {
                return `${formatAuthor(authors[0], true)} et al.`;
            }
        }

        // Update statistics
        function updateStatistics() {
            const totalCitations = citedSentences.reduce((sum, s) => sum + s.citations.length, 0);
            const citedSentenceCount = citedSentences.filter(s => s.citations.length > 0).length;
            const uniqueSources = references.length;
            const validDOIs = references.filter(r => r.doi).length;
            const coverage = citedSentences.length > 0 ? 
                Math.round((citedSentenceCount / citedSentences.length) * 100) : 0;
            
            document.getElementById('stat-citations').textContent = totalCitations;
            document.getElementById('stat-sentences').textContent = citedSentenceCount;
            document.getElementById('stat-sources').textContent = uniqueSources;
            document.getElementById('stat-dois').textContent = validDOIs;
            document.getElementById('stat-coverage').textContent = coverage + '%';
        }

        // Scroll to reference
        function scrollToReference(refNumber) {
            const refElement = document.getElementById(`ref-${refNumber}`);
            if (refElement) {
                refElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                refElement.style.background = '#fef3c7';
                setTimeout(() => {
                    refElement.style.background = 'white';
                }, 2000);
            }
        }

        // Copy to clipboard
        function copyToClipboard() {
            const citedText = document.getElementById('citedText').innerText;
            const referencesText = document.getElementById('referencesList').innerText;
            const fullText = citedText + '\n\nReferences\n' + referencesText;
            
            navigator.clipboard.writeText(fullText).then(() => {
                alert('Copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        // Export to Word format
        function exportToWord() {
            const citedHTML = document.getElementById('citedText').innerHTML;
            const referencesHTML = document.getElementById('referencesList').innerHTML;
            
            const fullHTML = `
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>Cited Text with Real References</title>
                    <style>
                        body { font-family: 'Times New Roman', serif; line-height: 2; margin: 1in; }
                        .cited-sentence { margin: 8px 0; }
                        .citation-number { color: blue; }
                        .reference-card { margin-bottom: 12px; }
                        h2 { font-weight: bold; margin-top: 24px; }
                    </style>
                </head>
                <body>
                    <h1>Text with Real Academic Citations</h1>
                    ${citedHTML}
                    <h2>References</h2>
                    ${referencesHTML}
                </body>
                </html>
            `;
            
            const blob = new Blob([fullHTML], { type: 'application/msword' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cited-text-real-${Date.now()}.doc`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Update citation style dynamically
        document.getElementById('citationStyle').addEventListener('change', function() {
            if (references.length > 0) {
                displayReferences();
            }
        });

        // Update DOI display dynamically
        document.getElementById('includeDOI').addEventListener('change', function() {
            if (references.length > 0) {
                displayReferences();
            }
        });

        // Update abstract display dynamically
        document.getElementById('includeAbstract').addEventListener('change', function() {
            if (references.length > 0) {
                displayReferences();
            }
        });

        // Update quality metrics display dynamically
        document.getElementById('showQualityMetrics').addEventListener('change', function() {
            if (references.length > 0) {
                displayReferences();
            }
        });

        // Update relevance score display dynamically
        document.getElementById('showRelevanceScore').addEventListener('change', function() {
            if (references.length > 0) {
                displayReferences();
            }
        });
    </script>
</body>
</html>
